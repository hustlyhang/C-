#GC
- Lua 5.0 之前从根集开始遍历对象，把能遍历到的对象标记为活对象；然后再遍历通过分配器分配出来的对象全集链表，把没有标记为活对象的其它对象都删除。
    
- Lua 5.0 开始，userdata支持__gc方法，当userdata被回收的时候，会调用这个方法，所以以前的回收方法就不够用了，不能简单的直接删除，需要先调用userdata的__gc方法，然后再删除，就相当于是__gc只会执行一次


- Lua 5.0 GC时机：每当内存分配总量超过上次 GC 后的两倍，就跑一遍新的 GC 流程。执行GC的过程会把整个虚拟机都停下来


- Lua 5.1 开始，Lua实现了一个步进式垃圾收集器，这个新的垃圾收集器会在虚拟机的正常指令逻辑间交错分布运行，尽量把每步的执行时间减到合理的范围。


- **三色标记法** Lua 5.1
    - 每个对象都有三个状态：无法被访问到的对象是白色，可访问到，但没有递归扫描完全的对象是灰色，完全扫描过的对象是黑色。
    - 规则
        1. 所有被根集引用的对象要么是黑色，要么是灰色的。
        1. 黑色的对象不可能指向白色的。
    - 白色对象集就是日后会被回收的部分；黑色对象集即使需要保留的部分；灰色的对象集就是黑色集和白色集的边界。随着收集器的运作，通过充分遍历灰色对象，就可以把它们转变为黑色对象，从而扩大黑色集。一旦所有灰色对象消失了，收集的过程也就完成了。
    - 黑-->白情况的处理，两种方法维持规则：```luaC_barrier, luaC_barrierback```
        1. 把白色对象变为灰色（forward）
        1. 把黑色对象变回灰色（backward）



参考
------
- [GC1](https://zhuanlan.zhihu.com/p/22403251)
- [GC2](https://www.cnblogs.com/gangtie/p/12724295.html)