# C++

- [static 关键字](https://www.zhihu.com/search?q=static%E5%85%B3%E9%94%AE%E5%AD%97&utm_content=search_suggestion&type=content)

    - 静态成员变量  
        - 不占用对象的内存空间，在没有产生类对象时其作用域就可见。因此，在没有类的实例存在时，静态成员变量就已经存在，我们就可以操作它。
        - 静态成员变量存储在全局数据区。
        - static 成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，***而是在初始化时分配***。静态成员变量必须初始化，而且只能在类体外进行。
        - static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。
        - 静态成员不需要通过对象就能访问。
        - 和全局变量的区别
            - 静态成员变量没有进入程序的全局命名空间，因此不存在与程序中其它全局命名冲突的可能。
            - 可以实现信息隐藏。静态成员变量可以是private成员，而全局变量不能。
    - 静态成员函数
        - 静态成员函数为类服务而不是为某一个类的具体对象服务。
        - 与普通函数相比，静态成员函数属于类本身，而不作用于对象，因此它不具有this指针。所以它无法访问属于类对象的非静态成员变量和非静态成员函数，它只能调用其余的静态成员函数和静态成员变量。
    - 静态全局变量
        - 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；
        - 静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量；
        - 对于一个完整的程序，在内存中的分布情况如下：【代码区】【全局数据区】【堆区】【栈区】，一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区，静态数据（即使是函数内部的静态局部变量）存放在全局数据区；
        - 与全局变量的区别
            - 静态全局变量不能被其它文件所用；
            - 其它文件中可以定义相同名字的变量，不会发生冲突；
    - 静态局部变量
        - 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
        - 静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；
    - 静态函数(类似静态全局变量)

- [delete 和 delete [] 区别](https://www.cnblogs.com/whwywzhj/p/7905176.html)
    - 针对简单类型 使用new分配后的不管是数组还是非数组形式内存空间用两种方式均可，原因在于分配简单类型内存时，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统并不会调用析构函数，它直               接通过指针可以获取实际分配的内存空间
    - delete ptr代表用来释放内存，且只用来释放ptr指向的内存。
    - delete[] rg 用来释放rg指向的内存，还逐一调用数组中每个对象的destructor！

- 隐式类型转换
    - 在表达式中，混合类型会发生隐式类型转换。
    - 可以用单个实参来调用的构造函数定义了从形参类型到该类型的一个隐式转换。

- [thread 和 pthread 的区别](https://blog.csdn.net/slslslyxz/article/details/110392528)
    - pthread是linux下的多线程API，头文件为pthread.h
    - std::thread是c++标准库中的线程库，其意义在于可以跨平台不改代码
    - 这篇文章讲了怎么多线程怎么传入非静态成员函数
 
- [std::ref](https://blog.csdn.net/lmb1612977696/article/details/81543802)
    - std::ref 用于包装按引用传递的值；std::cref 用于包装按const引用传递的值。
    
- [自旋锁和互斥锁](https://blog.csdn.net/fadbgfnbxb/article/details/90048851)
    - 自旋锁会一直占用CPU，而互斥锁会进入休眠，不占用CPU；
    - 这样做的好处是节省了线程从睡眠状态到唤醒之间内核会产生的消耗，在加锁时间短暂的环境下这点会提高很大效率。适用于锁的持有时间比较短。

- [函数调用](https://www.zhihu.com/question/22444939/answer/22200552)
    - 函数调用压栈是从右往左，是调用方进行压栈
    - stdcall和cdecl区别：stdcall是函数自己将参数弹出，cdecl是调用者将参数弹出
    - stdcall的调用约定意味着：1）参数从右向左压入堆栈，2）函数自身修改堆栈 3)函数名自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸

- [哈希冲突](https://zhuanlan.zhihu.com/p/29520044)
    - 开放定址法（再散列法）：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi                ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：
        - 线性探测再散列
        - 二次探测再散列
        - 伪随机探测再散列
    - 再哈希法：当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。
    - 链地址法：链地址法适用于经常进行插入和删除的情况。
    - 建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。

- [结构体](https://zhuanlan.zhihu.com/p/30007037)
    - 内存对齐；每个数据既要保证自己的对齐字节基准（自己大小和pragma定义中的较小的一个），又要让自己的地址在边界上，最后还要保证结构体大小是所有使用过数据类型的整数倍。
    - #pragma pack(n)   这个参数告诉编译器按照n个字节对齐。
    - 有效对齐值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。
    - 规则：
        - 结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。
        -  结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。

- [引用和指针](https://www.zhihu.com/question/37608201/answer/1601079930)
    - 引用只是c++语法糖，可以看作编译器自动完成取地址、解引用的常量指针
    - 指针和引用的自增(++）和自减含义不同，指针是指针运算, 而引用是代表所指向的对象对象执行++或--
    - “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小
    - [补充](https://www.cnblogs.com/ronny/p/3662556.html)

- [lambda](https://zhuanlan.zhihu.com/p/150554945)
    - 编译器会把我们写的lambda表达式翻译成一个类，并重载 operator()来实现。比如我们写一个lambda表达式为[补充](https://zhuanlan.zhihu.com/p/384314474)
    ```C++
    auto plus = [] (int a, int b) -> int { return a + b; }
    int c = plus(1, 2);
    
    // 类名随机取得一个
    class LambdaClass
    {
    public:
        int operator () (int a, int b) const
        {
            return a + b;
        }
    };

    LambdaClass plus;
    int c = plus(1, 2);
    ```
    调用的时候编译器会生成一个Lambda的对象，并调用opeartor ()函数。（备注：这里的编译的翻译结果并不和真正的结果完全一致，只是把最主要的部分体现出来，其他的像类到函数指针的转换函数均省略）
    - 值捕获：值捕获时，编译器会把捕获到的值作为类的成员变量，并且变量是以值的方式传递的。需要注意的时，如果所有的参数都是值捕获的方式，那么生成的operator()函数是const函数的，是无法修改捕获的值的，哪怕这个修改不会改变lambda表达式外部的变量，如果想要在函数内修改捕获的值，需要加上关键字 mutable。向下面这样的形式。
    ```C++
    int x = 1; int y = 2;
    auto plus = [=] (int a, int b) mutable -> int { x++; return x + y + a + b; };
    int c = plus(1, 2);
    ```
    - 捕获列表，对应LambdaClass类的private成员。

    - 参数列表，对应LambdaClass类的成员函数的operator()的形参列表mutable，对应 LambdaClass类成员函数 operator() 的const属性 ，但是只有在捕获列表捕获的参数不含有引用捕获的情况下才会生效，因为捕获列表只要包含引用捕获，那operator()函数就一定是非const函数。

    - 返回类型，对应 LambdaClass类成员函数 operator() 的返回类型

    - 函数体，对应 LambdaClass类成员函数 operator() 的函数体。

    - 引用捕获和值捕获不同的一点就是，对应的成员是否为引用类型。

- [右值引用](https://zhuanlan.zhihu.com/p/97128024)
    - 创建和销毁由编译器幕后控制，程序员只能确保在本行代码有效的，就是右值(包括立即数)；而用户创建的，通过作用域规则可知其生存期的，就是左值(包括函数返回的局部变量的引用以及const对象)。
    - 右值引用的存在并不是为了取代左值引用，而是充分利用右值(特别是临时对象)的构造来减少对象构造和析构操作以达到提高效率的目的。
    
# linux网络编程
- [半连接队列](https://zhuanlan.zhihu.com/p/99152064?from_voters_page=true)
    - [SYN-Cookies算法](https://segmentfault.com/a/1190000019292140)

# 算法
- [排序复杂度](https://blog.csdn.net/gane_cheng/article/details/52652705)
    - 插入排序：直接插入排序（稳定）、二分法插入排序、希尔排序。
    - 选择排序：直接选择排序、堆排序。
    - 交换排序：冒泡排序（稳定）、快速排序。
    - 归并排序（稳定）
    - 基数排序（稳定）

# 数据库
- [数据库索引](https://zhuanlan.zhihu.com/p/23624390)
    - 聚集索引
        - 不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径。然而， 有一种例外可以不使用聚集索引就能查询出所需要的数据， 这种非主流                             的方法称之为「覆盖索引」查询， 也就是平时所说的复合索引或者多字段索引查询
    - 非聚集索引
        - 每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间。
        - 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据
    - [面试常问](https://zhuanlan.zhihu.com/p/340593296)
    - 索引种类
        - 主键索引
        - 组合索引
        - 唯一索引
        - 全文索引
        - 普通索引

- [输入一条查询语句后](https://www.infoq.cn/article/PKzT75BPcryCYJ_VuWrR)

    - MySQL：分为Server层和存储引擎层；Server层包括连接器、查询缓存、分析器、优化器、执行器等
    - 连接器：连接器负责跟客户端建立连接、获取权限、维持和管理连接。
    - 查询缓存：MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。
    - 分析器：首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。
        - “词法分析”：MySQL 需要识别出里面的字符串分别是什么，代表什么。
        - “语法分析”：根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。

    - 优化器：优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。
    - 执行器：开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误

# 操作系统

- [内存地址编址与寻址原理剖析](https://blog.csdn.net/u014689845/article/details/102752718)
    - 物理地址：加载到内存地址寄存器中的地址，内存单元的真正地址。
    - 逻辑地址：CPU所生成的地址。逻辑地址是内部和编程使用的、并不唯一。
    - 逻辑地址到物理地址的映射机制：
        - 分页：使得进程的物理地址空间可以是非连续的。物理内存被划分为一小块一小块，每块被称为帧(Frame)。分配内存时，帧是分配时的最小单位，最少也要给一帧。在逻辑内存中，与帧对应的概念就是页   (Page)。
        - 逻辑地址的表示方式是：前部分是页码后部分是页偏移。
        - 32位的逻辑地址，页大小为4K（2^12B），总空间为2^32B，算下来一个页表可以有2^(32 - 12)个条目，假设每个条目占有4B，那么每个进程就需要4B*2^20 = 2^22B = 4MB来存放页表，
        - 层次化分页：

- [进程间通信]()
    - 管道：一个管道只能实现有亲缘关系的两个进程单向通信，如果要实现双向通信，需要两个管道或者使用[sockpair](https://blog.csdn.net/weixin_40039738/article/details/81095013)解决
    - 命名管道（FIFO）：FIFO不同于管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存储文件系统中。命名管道是一个设备文件，因此即使进程与创建FIFO的进程不存在亲缘关系，只要可以访问该路径，就能够通过FIFO相互通信。```int mkfifo(const char *pathname, mode_t mode);```
        - 命名管道是一个存在于硬盘上的文件，而管道是存在于内存中的特殊文件。所以当使用命名管道的时候必须先open将其打开。
        - 命名管道可以用于任何两个进程之间的通信，不管这两个进程是不是父子进程，也不管这两个进程之间有没有关系。

    - 消息队列：一是通信不及时，二是附件也有大小限制
    - 信号量：信号量的本质是一种数据操作锁，用来负责数据操作过程中的互斥，同步等功能。
        ```C++
        int semget(key_t key, int nsems, int semflg);
        key = key_t ftok(const char *pathname, int proj_id);
        int semop(int semid, struct sembuf *sops, unsigned nsops);
        int semtimedop(int semid, struct sembuf *sops, unsigned nsops,struct timespec *timeout);
        int semctl(int semid,int semnum,int cmd,...);
        ```
        nsems:这个参数表示你要创建的信号量集合中的信号量的个数。信号量只能以集合的形式创建。
    - 共享内存(shm)
    - 信号
    - Socket




# 计算机网路

- [TCP流量控制、拥塞控制](https://blog.csdn.net/gengzhikui1992/article/details/89141184)
    - 流量控制：根据接受方的**接收窗口**来控制发送方的数据发送
    - 拥塞控制：
        - 慢开始、拥塞避免
        - 快重传、快恢复（三个重复确认），在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用

    - 区别：

        - 拥塞控制：拥塞控制是作用于**网络**的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。
        - 流量控制：流量控制是作用于**接收者**的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。

- [TCP可靠性的保证机制总结](https://blog.csdn.net/xuzhangze/article/details/80490362?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163072630116780271576933%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=163072630116780271576933&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-80490362.pc_search_result_cache&utm_term=TCP%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%E4%BF%9D%E8%AF%81%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93&spm=1018.2226.3001.4187t)
    - 校验和：加上12byte伪首部，包括tcp首部和数据部分；将整个报文段分为多个16位的段，将所有段进行反码相加，将结果保存在检验和字段中，接收方用相同的方法进行计算，如最终结果为检验字段所有位是全1则正确
    - 序列号：a、保证可靠性（当接收到的数据总少了某个序号的数据时，能马上知道）b、保证数据的按序到达 c、提高效率，可实现多次发送，一次确认 d、去除重复数据
    - 确认应答机制
    - 超时重传机制
    - 连接管理：三次握手、三次挥手
    - 流量控制
    - 拥塞控制
