# C++

- [static 关键字](https://www.zhihu.com/search?q=static%E5%85%B3%E9%94%AE%E5%AD%97&utm_content=search_suggestion&type=content)

    - 静态成员变量  
        - 不占用对象的内存空间，在没有产生类对象时其作用域就可见。因此，在没有类的实例存在时，静态成员变量就已经存在，我们就可以操作它。
        - 静态成员变量存储在全局数据区。
        - static 成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，***而是在初始化时分配***。静态成员变量必须初始化，而且只能在类体外进行。
        - static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。
        - 静态成员不需要通过对象就能访问。
        - 和全局变量的区别
            - 静态成员变量没有进入程序的全局命名空间，因此不存在与程序中其它全局命名冲突的可能。
            - 可以实现信息隐藏。静态成员变量可以是private成员，而全局变量不能。
    - 静态成员函数
        - 静态成员函数为类服务而不是为某一个类的具体对象服务。
        - 与普通函数相比，静态成员函数属于类本身，而不作用于对象，因此它不具有this指针。所以它无法访问属于类对象的非静态成员变量和非静态成员函数，它只能调用其余的静态成员函数和静态成员变量。
    - 静态全局变量
        - 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；
        - 静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量；
        - 对于一个完整的程序，在内存中的分布情况如下：【代码区】【全局数据区】【堆区】【栈区】，一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区，静态数据（即使是函数内部的静态局部变量）存放在全局数据区；
        - 与全局变量的区别
            - 静态全局变量不能被其它文件所用；
            - 其它文件中可以定义相同名字的变量，不会发生冲突；
    - 静态局部变量
        - 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
        - 静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；
    - 静态函数(类似静态全局变量)

- [delete 和 delete [] 区别](https://www.cnblogs.com/whwywzhj/p/7905176.html)
    - 针对简单类型 使用new分配后的不管是数组还是非数组形式内存空间用两种方式均可，原因在于分配简单类型内存时，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统并不会调用析构函数，它直接通         过指针可以获取实际分配的内存空间
    - delete ptr代表用来释放内存，且只用来释放ptr指向的内存。
    - delete[] rg 用来释放rg指向的内存，还逐一调用数组中每个对象的destructor！

- 隐式类型转换
    - 在表达式中，混合类型会发生隐式类型转换。
    - 可以用单个实参来调用的构造函数定义了从形参类型到该类型的一个隐式转换。

- [thread 和 pthread 的区别](https://blog.csdn.net/slslslyxz/article/details/110392528)
    - pthread是linux下的多线程API，头文件为pthread.h
    - std::thread是c++标准库中的线程库，其意义在于可以跨平台不改代码
    - 这篇文章讲了怎么多线程怎么传入非静态成员函数
 
- [std::ref](https://blog.csdn.net/lmb1612977696/article/details/81543802)
    - std::ref 用于包装按引用传递的值；std::cref 用于包装按const引用传递的值。
    
- [自旋锁和互斥锁](https://blog.csdn.net/fadbgfnbxb/article/details/90048851)
    - 自旋锁会一直占用CPU，而互斥锁会进入休眠，不占用CPU；
    - 这样做的好处是节省了线程从睡眠状态到唤醒之间内核会产生的消耗，在加锁时间短暂的环境下这点会提高很大效率。适用于锁的持有时间比较短。

- [函数调用](https://www.zhihu.com/question/22444939/answer/22200552)
    - 函数调用压栈是从右往左，是调用方进行压栈
    - stdcall和cdecl区别：stdcall是被调用者将参数弹出，cdecl是调用者将参数弹出

- [哈希冲突](https://zhuanlan.zhihu.com/p/29520044)
    - 开放定址法（再散列法）：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，                              将相应元素存入其中。这种方法有一个通用的再散列函数形式：
        - 线性探测再散列
        - 二次探测再散列
        - 伪随机探测再散列
    - 再哈希法：当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。
    - 链地址法：链地址法适用于经常进行插入和删除的情况。
    - 建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。

# linux网络编程
- [半连接队列](https://zhuanlan.zhihu.com/p/99152064?from_voters_page=true)
    - [SYN-Cookies算法](https://segmentfault.com/a/1190000019292140)

# 算法
- [排序复杂度](https://blog.csdn.net/gane_cheng/article/details/52652705)
    - 插入排序：直接插入排序（稳定）、二分法插入排序、希尔排序。
    - 选择排序：直接选择排序、堆排序。
    - 交换排序：冒泡排序（稳定）、快速排序。
    - 归并排序（稳定）
    - 基数排序（稳定）

# 数据库
- [数据库索引](https://zhuanlan.zhihu.com/p/23624390)
    - 聚集索引
        - 不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径。然而， 有一种例外可以不使用聚集索引就能查询出所需要的数据， 这种非主流的方                   法称之为「覆盖索引」查询， 也就是平时所说的复合索引或者多字段索引查询
    - 非聚集索引
        - 每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间。
        - 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据
    - [面试常问](https://zhuanlan.zhihu.com/p/340593296)
    - 索引种类
        - 主键索引
        - 组合索引
        - 唯一索引
        - 全文索引
        - 普通索引

# 操作系统

# 计算机网路
