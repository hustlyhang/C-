# C++
- [static 关键字](https://www.zhihu.com/search?q=static%E5%85%B3%E9%94%AE%E5%AD%97&utm_content=search_suggestion&type=content)

    - 静态成员变量  
        - 不占用对象的内存空间，在没有产生类对象时其作用域就可见。因此，在没有类的实例存在时，静态成员变量就已经存在，我们就可以操作它。
        - 静态成员变量存储在全局数据区。
        - static 成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，***而是在初始化时分配***。静态成员变量必须初始化，而且只能在类体外进行。
        - static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。
        - 静态成员不需要通过对象就能访问。
        - 和全局变量的区别
            - 静态成员变量没有进入程序的全局命名空间，因此不存在与程序中其它全局命名冲突的可能。
            - 可以实现信息隐藏。静态成员变量可以是private成员，而全局变量不能。
    - 静态成员函数
        - 静态成员函数为类服务而不是为某一个类的具体对象服务。
        - 与普通函数相比，静态成员函数属于类本身，而不作用于对象，因此它不具有this指针。所以它无法访问属于类对象的非静态成员变量和非静态成员函数，它只能调用其余的静态成员函数和静态成员变量。
    - 静态全局变量
        - 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；
        - 静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量；
        - 对于一个完整的程序，在内存中的分布情况如下：【代码区】【全局数据区】【堆区】【栈区】，一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区，静态数据（即使是函数内部的静态局部变量）存放在全局数据区；
        - 与全局变量的区别
            - 静态全局变量不能被其它文件所用；
            - 其它文件中可以定义相同名字的变量，不会发生冲突；
    - 静态局部变量
        - 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
        - 静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；
    - 静态函数(类似静态全局变量)
- [delete 和 delete [] 区别](https://www.cnblogs.com/whwywzhj/p/7905176.html)
    - 针对简单类型 使用new分配后的不管是数组还是非数组形式内存空间用两种方式均可，原因在于分配简单类型内存时，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统并不会调用析构函数，它直接通过指针可以获取实际分配的内存空间
    - delete ptr代表用来释放内存，且只用来释放ptr指向的内存。
    - delete[] rg 用来释放rg指向的内存，还逐一调用数组中每个对象的destructor！
- 隐式类型转换
    - 在表达式中，混合类型会发生隐式类型转换。
    - 可以用单个实参来调用的构造函数定义了从形参类型到该类型的一个隐式转换。



# 算法
- [排序复杂度](https://blog.csdn.net/gane_cheng/article/details/52652705)
    - 插入排序：直接插入排序（稳定）、二分法插入排序、希尔排序。
    - 选择排序：直接选择排序、堆排序。
    - 交换排序：冒泡排序（稳定）、快速排序。
    - 归并排序（稳定）
    - 基数排序（稳定）

# 数据库

# 操作系统

# 计算机网路